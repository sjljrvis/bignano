const request = require('request');
const mongoose = require('mongoose');
const express = require('express');
const bodyParser = require('body-parser')

module.exports = function sjl() {

	this.settings = arguments[0]; /* First argument has to be settings object for project */
	this.db = null;
	this.routes = arguments[0].routes;
	this.models = arguments[0].models.map((_element) => { return _element.name });

	this.app = express();
	this.app.use(bodyParser.json());
	this.app.use(bodyParser({ urlencoded: true }));

	this.initMiddlewares = () => {
		arguments[0].middlewares.forEach(element => {
			this.app.use(element);
		});
	}

	this.initSchema = () => {
		arguments[0].models.forEach(element => {
			let _schema = new mongoose.Schema(element.schema);
			this.db.model(element.name, element.schema)
		});
	}

	this.initDB = () => {
		this.db = mongoose.createConnection(`mongodb://${this.settings.mongoDB.userName}:${this.settings.mongoDB.password}@${this.settings.mongoDB.host}:${this.settings.mongoDB.port}/${this.settings.mongoDB.databaseName}`)
		this.db.once('open', () => {
			console.log("Connected to DB ->", this.settings.mongoDB.host);
		});
		this.db.on('error', console.error.bind(console, 'mongoose connection error: '));
	}


	this.initPort = () => {
		this.app.listen(arguments[0].port, () => {
			console.log("server listening to port ->", arguments[0].port);
		});
	}

	/**
	 * Handling express request here , 
	 * GET request needs to be handled with pagination ,searching and sorting fuctions
	 * autogenerated contollers for PUT and DELETE needs query params @_id
	 */
	this.handleExpressRequest = () => {
		this.routes.forEach(element => {
			if (element.autoGenerate) {
				element.methods.forEach(_element => {
					switch (_element.toUpperCase()) {
						case "GET": {
							this.app.get(element.path, (req, res) => {
								this.db.models[element.model].find({}, (err, result) => {
									res.json({ status: true, result })
								});
							})
							break
						};
						case "POST": {
							this.app.post(element.path, (req, res) => {
								let _payload = {};
								Object.keys(req.body).map(x => {
									_payload[x] = req.body[x];
								})
								this.db.models[element.model].create(_payload, (err, result) => {
									res.json({ status: true, result })
								});
							})
							break
						};
						case "PUT": {
							this.app.put(`${element.path}/:_id`, (req, res) => {
								this.db.models[element.model].findOne({ "_id": req.params._id }, (err, result) => {
									Object.keys(req.body).map(x => {
										result[x] = req.body[x];
									})
									result.save();
									res.json({ status: true, result })
								});
							});
							break
						};
						case "DELETE": {
							this.app.delete(`${element.path}/:_id`, (req, res) => {
								this.db.models[element.model].remove({ "_id": req.params._id }, (err, result) => {
									res.json({ status: true, result })
								});
							});
							break
						};
						default: console.log(`Method ${_element} not yet supported`);
					}
				})
			}
			else {
				this.app[element.methods[0].toLowerCase()](element.path, element.controller)
			}
		});
	};

	/* Connecting app to mongoDB and registering PORT */
	sjl.prototype.init = () => {
		this.initDB();
		this.initSchema();
		this.initPort(this.settings);
		this.initMiddlewares(this.settings);
		this.handleExpressRequest();
	};

	sjl.prototype.getSettings = () => {
		return this.settings;
	};

	/* Returning DB instance for custom usage  */
	sjl.prototype.getDBInstance = () => {
		return this.db;
	}
}
